{/* Metadata and imports */}
import BackButton from '@/components/BackButton/BackButton';
export const metadata = {
title: 'Building a real time Spotify "Now Playing" Component',
alternates: {
canonical: '/blogs/spotify-playing-component',
},
date: '22/03/2025',
};

<BackButton />

{/* Blog starts from here ->-> */}

# Building a real time Spotify "Now Playing" Component

<p className="text-neutral-400 mb-8 mt-2">
  {metadata.date}
</p>

As a music enthusiast and developer, I wanted to share my current music taste with visitors to my personal website. In this blog post, I'll walk through how I built a real-time "Now Playing" Spotify integration for my Next.js website.

## The Vision

I wanted a subtle but engaging component that would:
- Display my currently playing Spotify track in real-time
- Automatically update when songs change
- Look elegant on my personal website
- Handle text overflow with a scrolling animation
- Degrade gracefully when no music is playing

## Technical Approach

The implementation required three main parts:
1. **Authentication with Spotify's API**
2. **Fetching the currently playing track**
3. **Creating a responsive React component**

Let's break down each part of the solution.

## Setting Up Spotify API Authentication

The first challenge was authentication. Spotify's API uses OAuth 2.0, which typically requires user interaction. Since I wanted this to work server-side without user input, I implemented the "Client Credentials Flow" with a refresh token.


```typescript
import queryString from "query-string";

const client_id = process.env.NEXT_PUBLIC_SPOTIFY_CLIENT_ID;
const client_secret = process.env.NEXT_PUBLIC_SPOTIFY_CLIENT_SECRET;
const refresh_token = process.env.NEXT_PUBLIC_SPOTIFY_REFRESH_TOKEN;
```

To avoid making unnecessary API calls, I implemented token caching:

```typescript
// Cache structure to store the token and its expiration
let tokenCache = {
  access_token: null,
  expires_at: 0,
};
```

The `getAccessToken` function checks if there's a valid cached token before requesting a new one:

```typescript
const getAccessToken = async () => {
  if (
    tokenCache.access_token &&
    tokenCache.expires_at &&
    Date.now() < tokenCache.expires_at
  ) {
    return { access_token: tokenCache.access_token };
  }
  
  // If no valid token, request new one...
}
```

## Fetching the Currently Playing Track

Once authentication was sorted, I created a function to fetch the currently playing track:

```typescript
export const getNowPlaying = async () => {
  const { access_token } = await getAccessToken();

  const response = await fetch(
    "https://api.spotify.com/v1/me/player/currently-playing",
    {
      headers: {
        Authorization: `Bearer ${access_token}`,
      },
      cache: "no-store",
      next: { revalidate: 0 },
    },
  );

  return response;
};
```

The important details here:
- Using `cache: "no-store"` and `revalidate: 0` to ensure we always get fresh data
- Keeping the function simple and focused on one responsibility

I then created a helper function to parse the response:

```typescript
export default async function getNowPlayingItem() {
  const response = await getNowPlaying();
  if (response.status === 204 || response.status > 400) {
    return false;
  }

  const song = await response.json();
  const artist = song.item.artists[0].name;
  const isPlaying = song.is_playing;
  const title = song.item.name;

  return {
    artist,
    isPlaying,
    title,
  };
}
```

## Building the React Component

The React component needed to:
1. Display initial data from the server
2. Periodically poll for updates
3. Handle overflow with a scrolling animation
4. Show different states based on playback status

Here's how I structured the component:

```tsx
const SpotifyStatus: React.FC<{ initialData: SpotifyData | false }> = ({
  initialData,
}) => {
  const [offline, setOffline] = useState<boolean>(!initialData);
  const [result, setResult] = useState<SpotifyData>(
    initialData || {
      artist: "",
      isPlaying: false,
      title: "",
    },
  );
  // ...more state and refs
```

### Handling Text Overflow

One of the more interesting challenges was handling text overflow. I wanted long track names to scroll horizontally when they didn't fit. This required:

1. References to measure the text and container widths
2. An effect to detect overflow
3. CSS animations to handle the scrolling

```tsx
useEffect(() => {
  const updateScrollBehavior = () => {
    if (textRef.current && containerRef.current) {
      const textWidth = textRef.current.scrollWidth;
      const containerWidth = containerRef.current.clientWidth;
      const isOverflowing = textWidth > containerWidth;
      setShouldScroll(isOverflowing);

      if (isOverflowing) {
        const translateX = -(textWidth - containerWidth) - 15;
        textRef.current.style.transform = `translateX(${translateX}px)`;
      } else {
        textRef.current.style.transform = "translateX(0)";
      }
    }
  };

  updateScrollBehavior();
  window.addEventListener("resize", updateScrollBehavior);

  return () => window.removeEventListener("resize", updateScrollBehavior);
}, [result]);
```

### Periodic Updates

To keep the displayed track current, I implemented polling:

```tsx
useEffect(() => {
  const interval = setInterval(async () => {
    try {
      const response = await fetch("/api/spotify/now-playing");
      const data = await response.json();

      if (!data || data.error) {
        setOffline(true);
      } else {
        setResult(data);
        setOffline(false);
      }
    } catch (error) {
      setOffline(true);
    }
  }, 5000);

  return () => clearInterval(interval);
}, []);
```

### The Final JSX

The component's render output is deliberately minimal but expressive:

```tsx
return (
  <div className="flex items-center">
    <div className="flex items-center mr-2">
      <SpotifyLogo
        width={14}
        height={14}
        color={!offline && result.isPlaying ? "#25d865" : "#a3a3a3"}
      />
    </div>
    <div ref={containerRef} className="w-full inline-block overflow-hidden">
      <div
        ref={textRef}
        className={`text-xs text-neutral-400 whitespace-nowrap ${
          shouldScroll ? "marquee" : ""
        }`}
      >
        <span>{scrollingText}</span>
      </div>
    </div>
  </div>
);
```

## Integration with Next.js App

Integrating the component into my Next.js home page was straightforward:

```tsx
export default async function Home() {
  const initialData = await getNowPlayingItem();
  return (
    <div className="mx-4 mb-32">
      {/* Other components */}
      <section className="z-1 pt-4 px-4">
        <SpotifyStatus initialData={initialData} />
      </section>
    </div>
  );
}
```

The key here is using `initialData` to provide server-rendered content before client-side JavaScript takes over.

## CSS Animation

In my global CSS file, I added this animation:

```css
@keyframes marquee {
  0% { transform: translateX(0); }
  100% { transform: translateX(var(--scroll-width)); }
}

.marquee {
  animation: marquee 10s linear infinite alternate;
}
```

## Challenges and Solutions

### Challenge 1: API Rate Limits

Spotify's API has rate limits, so I needed to ensure I wasn't making too many requests. I addressed this by:
- Caching the access token
- Using a reasonable polling interval
- Handling errors gracefully

### Challenge 2: Cross-browser Animation Compatibility

Getting smooth scrolling animations working consistently across browsers was tricky. I found that using CSS variables for the animation distance worked best:

```javascript
// Set the CSS variable dynamically
textRef.current.style.setProperty('--scroll-width', `${translateX}px`);
```

### Challenge 3: Server/Client Hydration

With Next.js, there's always the challenge of ensuring smooth hydration between server and client rendering. I solved this by:
- Making the component a client component with "use client"
- Providing initial data from the server
- Having sensible defaults for when data is loading

## Future Improvements

There are several ways I plan to enhance this component:
- Add album artwork thumbnails
- Display playback progress
- Add animation when songs change
- Improve accessibility
- Add more customization options

## Conclusion

Building this Spotify integration was a fun project that adds a personal touch to my website. The combination of Next.js server components for initial data fetching and client components for real-time updates works beautifully.

Feel free to adapt this approach for your own projects! The full code is available in my GitHub repository.

---

## Getting Started with Your Own Implementation

To implement this on your own site:

1. Create a Spotify Developer account and register an application
2. Obtain your client ID and client secret
3. Generate a refresh token (several tutorials online can help with this)
4. Set up your environment variables
5. Clone or adapt the code shown in this post

Happy coding and happy listening!